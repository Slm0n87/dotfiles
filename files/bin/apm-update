#!/bin/sh

# You can override the apm_bundle location as an environment variable, in a
# config file, or by editing this file. You can also override the conffile
# location. Sample conffile:
#
# export apm_bundle=/Users/foo/src/work/apm_bundle

# DEBUG can also set child processes to DEBUG output, so also provide DEBUG_APMU
[ ! -z "$DEBUG_APMU"] && set -x

readonly ARGS="$@"

trap 'kill 0' INT TERM EXIT

: ${conffile:=$HOME/.apm-updaterc}
: ${apm_bundle:=$HOME/code/apm_bundle}

[ -f $conffile ] && . $conffile

HACK__GEMFILE_LOCK_COMMAND='git ls-files \*Gemfile.lock | xargs git checkout'

GIT_FETCH='git fetch --all --prune'
GIT_PULL='git pull --rebase origin master'

function help() {
  local script=$(basename $0)
  printf "
apm-update: Easily update your APM environment

apm-update is cool because it intelligently parallelizes git pulling, bundling,
and rake-db:migrating, to make it as fast as possible. It also tries 'bundle
--local' to make bundling faster. And it has pretty colors. Check the source
($0) for help locating your apm_bundle directory.

Usage: $script [OPTIONS]

OPTIONS:
  -B  No bundle
  -C  No colors (Colors are automatically disabled when piping)
  -G  No git operations '$GIT_FETCH' and '$GIT_PULL'
  -H  No hacks (temporary fixes). See 'hack__*' functions in source.
  -M  No rake db:migrate
  -P  No parallelism. Do everything in serial. SLOWER.
  -q  Quiet. Only show output from this script (quiet bundle, git, rake, etc.)
  -s  Silent. Suppress all STDOUT output (still shows STDERR).
  -h  Show this help

(Supports debug output thusly: DEBUG_APMU=1 $script)
"
}

function parse_options() {
  local OPTIND
  local OPTARG
  local opt
  while getopts 'hBCGHMPqs' opt; do
    case "$opt" in
      h)
        help
        exit 0
        ;;
      B)
        OPTS__no_bundle=1
        ;;
      C)
        OPTS__no_color=1
        ;;
      G)
        OPTS__no_git=1
        ;;
      H)
        OPTS__no_hacks=1
        ;;
      M)
        OPTS__no_migrate=1
        ;;
      P)
        OPTS__no_parallel=1
        ;;
      q)
        OPTS__quiet=1
        ;;
      s)
        OPTS__silent=1
        ;;
    esac
  done
}

function bundle_enabled() {
  [ -z "$OPTS__no_bundle" ]
}

function colors_enabled() {
  [ -z "$OPTS__no_color" ]
}

function git_enabled() {
  [ -z "$OPTS__no_git" ]
}

function hacks_enabled() {
  [ -z "$OPTS__no_hacks" ]
}

function migrate_enabled() {
  [ -z "$OPTS__no_migrate" ]
}

function parallelism_enabled() {
  [ -z "$OPTS__no_parallel" ]
}

function quiet_enabled() {
  [ ! -z "$OPTS__quiet" ]
}

function silence_enabled() {
  [ ! -z "$OPTS__silent" ]
}

function tell() {
  printf "$@\n"
  printf "$DEFAULT"
}

function do_bundle() {
  local app=$1; shift
  local bundle_args=''
  if [ -f Gemfile ]; then
    tell "${BLUE}$app${GREEN}: Bundling..."
    colors_enabled || bundle_args="$bundle_args --no-color"
    quiet_enabled  && bundle_args="$bundle_args --quiet"
    bundle --local $bundle_args || bundle $bundle_args
  else
    tell "${BLUE}$app${YELLOW}: No Gemfile. I won't bundle."
  fi
}

function do_migrate() {
  local app=$1; shift
  local migrate_args=''
  local env
  if [ -f config/database.yml ]; then
    for env in test development; do
      tell "${BLUE}$app${GREEN}: Migrating env $env..."
      quiet_enabled && migrate_args="$migrate_args VERBOSE=false"
      RAILS_ENV=$env rake db:migrate $migrate_args&
      parallelism_enabled || wait
    done
    wait
  else
    tell "${BLUE}$app${YELLOW}: No config/database.yml. I won't migrate."
  fi
}

function bundle_and_migrate() {
  local app="$1"; shift
  tell "${GREEN}Entering ${BLUE}$app${GREEN}..."
  cd $app
  bundle_enabled  && do_bundle  $app
  migrate_enabled && do_migrate $app
}

# XXX Check out gme
function hack__gemfile_lock() {
  if hacks_enabled; then
    tell "${MAGENTA}Applying Gemfile.lock hack '${HACK__GEMFILE_LOCK_COMMAND}'..."
    cd $apm_bundle
    eval "$HACK__GEMFILE_LOCK_COMMAND" # We need eval because there's a pipe.
  else
    tell "${YELLOW}Hacks disabled. Skipping Gemfile.lock hack: '${HACK__GEMFILE_LOCK_COMMAND}'."
  fi
}

function do_git() {
  local git_args=''
  for command in "$GIT_FETCH" "$GIT_PULL"; do
    if git_enabled; then
      tell "${GREEN}Doing ${command}..."
      quiet_enabled && git_args="$git_args --quiet"
      $command $git_args
    else
      tell "${YELLOW}Git disabled. Skipping ${command} ${git_args}."
    fi
  done
}

function is_terminal() {
  [ -t 1 ]
}

function set_colors() {
  if colors_enabled && is_terminal; then
    BLACK="\033[30m"
    RED="\033[31m"
    GREEN="\033[32m"
    YELLOW="\033[33m"
    BLUE="\033[34m"
    MAGENTA="\033[35m"
    CYAN="\033[36m"
    WHITE="\033[37m"
    DEFAULT="\033[0m"
  fi
}

function silence() {
  exec 1>/dev/null
}

function main() {
  local dir

  parse_options $ARGS
  silence_enabled && silence
  set_colors

  tell "${GREEN}Entering ${BLUE}${apm_bundle}${GREEN}..."
  cd $apm_bundle
  do_git

  for dir in $apm_bundle/apps/* $apm_bundle/apps/property/engines/* ; do
    bundle_and_migrate "$dir" &
    parallelism_enabled || wait
  done
  wait

  hack__gemfile_lock
}
main
